/** ****************************************************************************************************
 * @file 			NV Memory.C
 * @brief			This is the Source file used to support NV_Memory.C
 * ****************************************************************************************************
 * @author			Hab S. Collector \n
 * Last Edited By:	Hab S. Collector \n
 *
 * @date			7/18/20 \n
 * Last Edit Date:  7/18/20 \n
 * @version       	See Main.C
 *
 * @param Development_Environment \n
 * Hardware:		ST32LM082 \n
 * IDE:             Atollic TrueStudio, VER 9.3.0 \n
 * Compiler:        GCC \n
 * Editor Settings: 1 Tab = 4 Spaces, Recommended Courier New 11
 *
 * @note            This file supports the use of Non Volatile memory on STM32L010C6
 *                  This is a category 2 device as defined in ST Manual RM0451
 *                  See section 4.1, page 45 for memory map information
 * 					This is an embedded application
 *		            It will be necessary to consult the reference documents before you can review this code.
 *                  It is suggested that the documents be reviewed in the order shown.
 *			          SuperStar Technical Manual
 *				      SuperStar User Manual
 *
 * @copyright		IMR Engineering
 * **************************************************************************************************** */

#include "NV_Memory.h"


/** ****************************************************************************************************
* @brief Write a byte value to the NVM
*
* @author 			Hab S. Collector \n
* Last Edited By:  	Hab S. Collector \n
*
* @note This function must not be called before NVM has been unlocked
* @note After writing activity the NVM must be locked
* @note See Appendix A.3 of the STM32l0x2 Reference for additional details
*
* @param NVM_AddressOffset is an integer increment above the base NVM address
* @return True if write success
*
* WHY: It will be necessary to store and retrieve various characteristics about the board in NVRAM \n
*
* STEP 1: Check for valid offset \n
* STEP 2: Write the address at the offset value and wait for it to finish \n
* STEP 3: Test and return
* **************************************************************************************************** */
bool_t write_ByteNVM(uint32_t NVM_AddressOffset, uint8_t ByteValue)
{

	// STEP 1:
	// Check for valid offset
	if ((NVM_AddressOffset == 0) || (NVM_AddressOffset > MAX_NVM_OFFSET))
		return(false);

	// STEP 2:
	// Write the address at the offset value and wait for it to finish
	*(uint8_t *)(DATA_E2_ADDR + NVM_AddressOffset) = ByteValue;
	while(FLASH->SR & FLASH_SR_BSY);

	// STEP 3:
	// Test and return
	if  (*(uint8_t *)(DATA_E2_ADDR + NVM_AddressOffset) != ByteValue)
	  return(false);
	else
	  return(true);

} // END OF write_ByteNVM


/** ****************************************************************************************************
* @brief Read a byte value from the NVM
*
* @author 			Hab S. Collector \n
* Last Edited By:  	Hab S. Collector \n
*
* @note See Appendix A.3 of the STM32l0x2 Reference for additional details
*
* @param NVM_AddressOffset is an integer increment above the base NVM address
* @return The value of the byte at the offset address
*
* WHY: It will be necessary to store and retrieve various characteristics about the board in NVRAM \n
*
* STEP 1: Check for valid offset \n
* STEP 2: Read NVM and return
* **************************************************************************************************** */
uint8_t read_ByteNVM(uint32_t NVM_AddressOffset)
{

	// STEP 1:
	// Check for valid offset
	if ((NVM_AddressOffset == 0) || (NVM_AddressOffset > MAX_NVM_OFFSET))
		return(false);

	// STEP 2:
	// Read and return
	return(*(uint8_t *)(DATA_E2_ADDR + NVM_AddressOffset));

} // END OF read_ByteNVM
